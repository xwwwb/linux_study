进程:
	1. 进程的定义	
		可执行程序文件
		运行中的程序
		操作系统资源调度的基本单位
			资源:内存 fd  cpu时间片 ....
		内存最小单位  bit    内存的最小管理单位  byte   

	2. 进程的组成
		数据: 全局变量 静态变量(已初始化,未初始化) 只读变量 
		代码: 进程的源代码
		堆栈: 变量 手动内存分配  

	3. 进程的模式
		用户模式: 应用程序正在运行
		内核模式: 调用系统调用 系统中断

	4. 进程的运行:
		4.1 手动运行
			命令 执行可执行程序
		4.2 调度
			ps -aue
			top
			nice renice  控制进程是否让步
				进程的优先级
			kill
			crontab 
			bg

	5. 如何创建进程
		5.1 system();//在程序中执行命令
			创建完后当前进程不再执行了(挂起),等被创建进程结束后再继续运行.

		5.2 fork  vfork 
			创建子进程:当前进程是父进程,被创建进程是子进程   创建完之后父子进程通知执行

			拷贝方式来创建,fork函数创建子进程,子进程拷贝父进程的所有代码并且记录进程上下文(运行到啥时候了)

			父进程的fork返回子进程id,子进程的fork返回0


		5.3 exec簇   OpenProcess
			execl execv execle execlp execvp

	6. 进程的状态
		运行时  睡眠  挂起  等待  死亡状态 僵尸 ....

	7. 进程的结束
		僵尸进程: 父进程创建了子进程,父进程先于子进程结束,子进程资源没有被释放,就会变成僵尸进程,持续占用系统资源(内核中有一颗树,树节点是进程数据  进程本身资源).

		子进程结束前,会向父进程发送 SIGCHILD信号,父进程收到信号后,回收子进程资源,然后父进程再结束.


		父进程  写一个  wait函数 等待子进程发送 SIGCHILD信号

		waitpid 

	8. 守护进程
		8.1 独立,记录其他进程的情况,记录操作系统   系统日志
		8.2 如何查看当前系统上的守护进程
			ps axj
			PXJID 为 -1的是守护进程
		8.3 如何创建守护进程
			8.3.1 守护进程的功能实现和其他进程一样
			8.3.2 如果希望把一个进程变成守护进程
				8.3.2.1 把它的父进程干掉
				8.3.2.2 摆脱终端控制
					关闭  0 1 2   文件描述符号
					0 1 2 是终端   0 标准输入设备  1 标准输出设备 2 标准错误输出设备
					重定向当前进程的io操作到   /dev/null 黑洞设备
				8.3.2.3 创建新的会话:
					摆脱原有会话,进程组的控制

		8.4 守护进程创建编程模型
			第一种:
				1. 创建新会话   setsid
				2. 改变当前工作目录 chdir
				3. 重设当前文件权限  umask
				4. 关闭文件			close
			第二种:
				1. 重设文件权限      umask
				2. 创建子进程        fork
				3. 让父进程结束 
				4. 创建新会话 		setsid
				5. 防止子进程成为僵尸进程    忽略掉SIGCHLD SIGHUP信号
				6. 改变当前工作目录 chdir
				7. 重定向文件描述符号  open dup2(fd,0) dup2(fd,1)
	9. 进程的组织形式
		进程
		多个进程组成一个进程组   进程组的组长  session进程 
		多个进程组组成一个会话

		
作业:
	1. 子进程滚动显示随机数,父进程控制其暂停或者继续
		父进程等待用户输入,如果用户输入  空格  ,设置共享文件内存为  1
								      回车                      0
		子进程里有个 while(*p);
